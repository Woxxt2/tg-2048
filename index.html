<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2048 Color Edition</title>
  <style>
    body {
      margin: 0; font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(to right, #1e1e2f, #2b2d42);
      color: white; display: flex; flex-direction: column; align-items: center; padding: 20px;
      height: 100vh; user-select: none;
    }
    h1 {
      margin-bottom: 10px;
      color: #ffcc00;
    }
    #game {
      position: relative;
      background: #12131a;
      border-radius: 15px;
      box-shadow: 0 0 15px rgba(0,0,0,0.4);
      display: grid;
      gap: 10px;
      margin-top: 20px;
      touch-action: none;
    }
    .cell {
      background: #222430;
      border-radius: 10px;
      box-shadow: inset 0 0 5px #000;
      border: 1px solid #44475a;
      position: relative;
    }
    .grid-line {
      position: absolute;
      background: rgba(255,255,255,0.1);
      pointer-events: none;
      z-index: 1;
    }
    /* –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ */
    #game .v-line {
      width: 1px; top: 0; bottom: 0;
    }
    /* –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ */
    #game .h-line {
      height: 1px; left: 0; right: 0;
    }
    .tile {
      position: absolute;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      text-shadow: 1px 1px 2px black;
      transition: top 0.2s ease, left 0.2s ease, transform 0.2s ease;
      user-select: none;
      cursor: default;
    }
    .tile[data-val="2"] { background-color: #FF6B6B; }
    .tile[data-val="4"] { background-color: #4ECDC4; }
    .tile[data-val="8"] { background-color: #45B7D1; }
    .tile[data-val="16"] { background-color: #FFBE0B; }
    .tile[data-val="32"] { background-color: #FB5607; }
    .tile[data-val="64"] { background-color: #8338EC; }
    .tile[data-val="128"] { background-color: #3A86FF; }
    .tile[data-val="256"] { background-color: #FF006E; }
    .tile[data-val="512"] { background-color: #9B5DE5; }
    .tile[data-val="1024"] { background-color: #00BBF9; }
    .tile[data-val="2048"] { background-color: #00F5D4; font-size: 24px; }
    .tile[data-val="4096"] { background-color: #F15BB5; font-size: 22px; }
    .tile[data-val="8192"] { background-color: #9B5DE5; font-size: 20px; }

    /* –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ */
    .tile.bomb {
      background-color: red;
      animation: pulse 1s infinite;
    }
    .tile.freeze {
      background-color: #0055ff;
    }
    .tile.teleport {
      background-color: #00ff99;
    }
    .tile.shuffle {
      background-color: #ff00ff;
    }
    .tile.mirror {
      background-color: #ff8800;
    }
    .tile.double {
      background-color: #8800ff;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    #menu {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: white;
      user-select: none;
    }
    #menu.hidden {
      display: none;
    }
    .mode-buttons {
      display: flex;
      gap: 15px;
      margin: 15px 0;
    }
    button {
      background-color: #ffcc00;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      color: #2b2d42;
      user-select: none;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #e6b800;
    }
    button.active {
      background-color: #00f5d4;
      color: #2b2d42;
    }
    #specialToggle {
      margin-bottom: 10px;
    }
    #score {
      font-size: 20px;
      margin-top: 10px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="menu">
    <h1>2048 Color Edition</h1>
    <h2>–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –∏–≥—Ä—ã</h2>
    <div class="mode-buttons">
      <button class="mode-btn active" data-size="4">4√ó4 (–∫–ª–∞—Å—Å–∏–∫–∞)</button>
      <button class="mode-btn" data-size="6">6√ó6</button>
      <button class="mode-btn" data-size="8">8√ó8 (—ç–∫—Å—Ç—Ä–∏–º)</button>
    </div>
    <button id="specialToggle">–û—Ç–∫–ª—é—á–∏—Ç—å —Å–ø–µ—Ü. –∫–ª–µ—Ç–∫–∏</button>
    <button id="startBtn">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
  </div>

  <div id="score">–°—á—ë—Ç: 0</div>
  <div id="game"></div>

  <script>
  (() => {
    const gameContainer = document.getElementById('game');
    const menu = document.getElementById('menu');
    const startBtn = document.getElementById('startBtn');
    const modeButtons = document.querySelectorAll('.mode-btn');
    const specialToggle = document.getElementById('specialToggle');
    const scoreElem = document.getElementById('score');

    let gridSize = 4;
    let specialEnabled = true;
    let board = [];
    let tiles = [];
    let tileSize = 0;
    let score = 0;
    let freezeCells = new Set(); // –∑–∞–º–æ—Ä–æ–∂–µ–Ω–Ω—ã–µ –∫–ª–µ—Ç–∫–∏, –∏–Ω–¥–µ–∫—Å—ã
    let mirrorMode = false;
    let mirrorMovesLeft = 0;
    let doubleMode = false;
    let doubleMovesLeft = 0;

    // –°–ø–µ—Ü. —Ç–∏–ø—ã —Å –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é (–≤ %)
    const specialTypes = [
      {type:'bomb', chance: 5},
      {type:'freeze', chance: 5},
      {type:'teleport', chance: 5},
      {type:'shuffle', chance: 3},
      {type:'mirror', chance: 3},
      {type:'double', chance: 3},
    ];

    // –í—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞
    modeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        modeButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        gridSize = +btn.dataset.size;
      });
    });

    // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Å–ø–µ—Ü. –∫–ª–µ—Ç–æ–∫
    specialToggle.addEventListener('click', () => {
      specialEnabled = !specialEnabled;
      specialToggle.textContent = specialEnabled ? '–û—Ç–∫–ª—é—á–∏—Ç—å —Å–ø–µ—Ü. –∫–ª–µ—Ç–∫–∏' : '–í–∫–ª—é—á–∏—Ç—å —Å–ø–µ—Ü. –∫–ª–µ—Ç–∫–∏';
    });

    startBtn.addEventListener('click', () => {
      startGame();
      menu.classList.add('hidden');
    });

    function createGrid() {
      gameContainer.innerHTML = '';
      freezeCells.clear();
      mirrorMode = false;
      mirrorMovesLeft = 0;
      doubleMode = false;
      doubleMovesLeft = 0;

      gameContainer.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
      gameContainer.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
      gameContainer.style.width = `${gridSize * 80 + (gridSize - 1) * 10}px`;
      gameContainer.style.height = `${gridSize * 80 + (gridSize - 1) * 10}px`;
      tileSize = 80;

      // –†–∏—Å—É–µ–º —è—á–µ–π–∫–∏
      for(let i=0; i<gridSize*gridSize; i++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        cell.style.width = tileSize + 'px';
        cell.style.height = tileSize + 'px';
        gameContainer.appendChild(cell);
      }

      // –î–æ–±–∞–≤–ª—è–µ–º —Å–µ—Ç–∫—É –ª–∏–Ω–∏–π
      for(let c=1; c<gridSize; c++) {
        const vline = document.createElement('div');
        vline.classList.add('grid-line', 'v-line');
        vline.style.left = (c * (tileSize + 10) - 5) + 'px';
        gameContainer.appendChild(vline);
      }
      for(let r=1; r<gridSize; r++) {
        const hline = document.createElement('div');
        hline.classList.add('grid-line', 'h-line');
        hline.style.top = (r * (tileSize + 10) - 5) + 'px';
        gameContainer.appendChild(hline);
      }
    }

    function newTileValue() {
      return Math.random() < 0.9 ? 2 : 4;
    }

    // –î–æ–±–∞–≤–∏—Ç—å —Å–ø–µ—Ü. –∫–ª–µ—Ç–∫—É —Å –Ω–µ–±–æ–ª—å—à–æ–π –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é
    function maybeSpecial() {
      if (!specialEnabled) return null;
      const rand = Math.random()*100;
      let sum = 0;
      for(const s of specialTypes) {
        sum += s.chance;
        if(rand <= sum) return s.type;
      }
      return null;
    }

    // –°–æ–∑–¥–∞–µ–º –ø–ª–∏—Ç–∫—É
    function createTile(value, row, col, special=null) {
      return {value, row, col, merged: false, special};
    }

    function initBoard() {
      board = [];
      for(let r=0; r<gridSize; r++) {
        const row = [];
        for(let c=0; c<gridSize; c++) {
          row.push(null);
        }
        board.push(row);
      }
      tiles = [];
      score = 0;
      scoreElem.textContent = `–°—á—ë—Ç: ${score}`;
      freezeCells.clear();
      mirrorMode = false;
      mirrorMovesLeft = 0;
      doubleMode = false;
      doubleMovesLeft = 0;

      addRandomTile();
      addRandomTile();
      render();
    }

    // –î–æ–±–∞–≤–∏—Ç—å —Å–ª—É—á–∞–π–Ω—É—é –ø–ª–∏—Ç–∫—É
    function addRandomTile() {
      const empty = [];
      for(let r=0; r<gridSize; r++) {
        for(let c=0; c<gridSize; c++) {
          if(board[r][c] === null && !freezeCells.has(r*gridSize+c)) {
            empty.push({r,c});
          }
        }
      }
      if(empty.length === 0) return false;

      const {r, c} = empty[Math.floor(Math.random()*empty.length)];
      const val = newTileValue();
      const special = maybeSpecial();
      const tile = createTile(val, r, c, special);
      board[r][c] = tile;
      tiles.push(tile);
      return true;
    }

    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø–ª–∏—Ç–æ–∫
    function render() {
      // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –ø–ª–∏—Ç–∫–∏
      const oldTiles = [...gameContainer.querySelectorAll('.tile')];
      oldTiles.forEach(t => t.remove());

      // –î–æ–±–∞–≤–ª—è–µ–º –ø–ª–∏—Ç–∫–∏
      for(const tile of tiles) {
        const el = document.createElement('div');
        el.classList.add('tile');
        el.dataset.val = tile.value;
        el.style.width = tileSize + 'px';
        el.style.height = tileSize + 'px';
        el.style.top = (tile.row*(tileSize+10)) + 'px';
        el.style.left = (tile.col*(tileSize+10)) + 'px';

        if(tile.special) el.classList.add(tile.special);

        el.textContent = tile.special ? specialName(tile.special) : tile.value;
        if(tile.value >= 2048) el.style.fontSize = '24px';
        if(tile.value >= 4096) el.style.fontSize = '20px';

        gameContainer.appendChild(el);
      }
    }

    function specialName(type) {
      switch(type) {
        case 'bomb': return 'üí£';
        case 'freeze': return '‚ùÑÔ∏è';
        case 'teleport': return 'üåÄ';
        case 'shuffle': return 'üîÄ';
        case 'mirror': return 'üîÑ';
        case 'double': return '√ó2';
      }
      return '';
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–æ–∂–Ω–æ –ª–∏ —Ö–æ–¥–∏—Ç—å
    function canMove() {
      for(let r=0; r<gridSize; r++) {
        for(let c=0; c<gridSize; c++) {
          const tile = board[r][c];
          if(tile === null) return true;
          const neighbors = [
            [r+1,c], [r-1,c], [r,c+1], [r,c-1]
          ];
          for(const [nr,nc] of neighbors) {
            if(nr<0||nr>=gridSize||nc<0||nc>=gridSize) continue;
            const ntile = board[nr][nc];
            if(ntile && ntile.value === tile.value) return true;
          }
        }
      }
      return false;
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ö–æ–¥–∞ –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ dir = 'up','down','left','right'
    function move(dir) {
      if(mirrorMode) {
        if(dir === 'left') dir = 'right';
        else if(dir === 'right') dir = 'left';
        else if(dir === 'up') dir = 'down';
        else if(dir === 'down') dir = 'up';
      }

      let moved = false;
      resetMerged();

      const vector = {
        'left':  {x: -1, y: 0},
        'right': {x: 1, y: 0},
        'up':    {x: 0, y: -1},
        'down':  {x: 0, y: 1},
      }[dir];

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ –æ–±—Ö–æ–¥–∞
      const startRow = vector.y === 1 ? gridSize-1 : 0;
      const endRow = vector.y === 1 ? -1 : gridSize;
      const stepRow = vector.y === 1 ? -1 : 1;

      const startCol = vector.x === 1 ? gridSize-1 : 0;
      const endCol = vector.x === 1 ? -1 : gridSize;
      const stepCol = vector.x === 1 ? -1 : 1;

      // –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –∫–ª–µ—Ç–∫–∏ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
      for(let r = startRow; r !== endRow; r += stepRow) {
        for(let c = startCol; c !== endCol; c += stepCol) {
          const tile = board[r][c];
          if(tile === null) continue;
          if(freezeCells.has(r*gridSize+c)) continue;

          let nr = r, nc = c;
          while(true) {
            const nextR = nr + vector.y;
            const nextC = nc + vector.x;
            if(nextR < 0 || nextR >= gridSize || nextC < 0 || nextC >= gridSize) break;
            if(freezeCells.has(nextR*gridSize+nextC)) break;

            const nextTile = board[nextR][nextC];
            if(nextTile === null) {
              board[nextR][nextC] = tile;
              board[nr][nc] = null;
              tile.row = nextR; tile.col = nextC;
              nr = nextR; nc = nextC;
              moved = true;
            } else if(!nextTile.merged && nextTile.value === tile.value && tile.special === null && nextTile.special === null) {
              const points = doubleMode ? nextTile.value * 4 : nextTile.value * 2;
              nextTile.value *= 2;
              nextTile.merged = true;
              board[nr][nc] = null;
              tiles = tiles.filter(t => t !== tile);
              score += points;
              scoreElem.textContent = `–°—á—ë—Ç: ${score}`;
              moved = true;
              nextTile.special = null;
              break;
            } else {
              break;
            }
          }
        }
      }

      if(moved) {
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫–∏ —Å–ø–µ—Ü—ç—Ñ—Ñ–µ–∫—Ç–æ–≤
        if(mirrorMovesLeft > 0) {
          mirrorMovesLeft--;
          if(mirrorMovesLeft === 0) mirrorMode = false;
        }
        if(doubleMovesLeft > 0) {
          doubleMovesLeft--;
          if(doubleMovesLeft === 0) doubleMode = false;
        }

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–ø–µ—Ü–∫–ª–µ—Ç–∫–∏
        handleSpecialTiles();
        
        // –°–Ω–∏–º–∞–µ–º –∑–∞–º–æ—Ä–æ–∑–∫—É –ø–æ—Å–ª–µ —Ö–æ–¥–∞
        freezeCells.clear();
        
        addRandomTile();
        render();

        if(!canMove()) {
          setTimeout(() => {
            alert(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –°—á—ë—Ç: ${score}`);
            menu.classList.remove('hidden');
          }, 100);
        }
      }
    }

    // –°–±—Ä–æ—Å —Ñ–ª–∞–≥–∞ merged –ø–µ—Ä–µ–¥ —Ö–æ–¥–æ–º
    function resetMerged() {
      for(const tile of tiles) {
        tile.merged = false;
      }
    }

    function handleSpecialTiles() {
      const specialTiles = tiles.filter(t => t.special);
      for(const tile of specialTiles) {
        const idx = tile.row * gridSize + tile.col;
        
        switch(tile.special) {
          case 'bomb':
            for(let r = Math.max(0, tile.row-1); r <= Math.min(gridSize-1, tile.row+1); r++) {
              for(let c = Math.max(0, tile.col-1); c <= Math.min(gridSize-1, tile.col+1); c++) {
                if(board[r][c] && board[r][c] !== tile) {
                  tiles = tiles.filter(t => t !== board[r][c]);
                  board[r][c] = null;
                }
              }
            }
            break;
            
          case 'freeze':
            for(let r = Math.max(0, tile.row-1); r <= Math.min(gridSize-1, tile.row+1); r++) {
              for(let c = Math.max(0, tile.col-1); c <= Math.min(gridSize-1, tile.col+1); c++) {
                if(board[r][c] && board[r][c] !== tile) {
                  freezeCells.add(r * gridSize + c);
                }
              }
            }
            break;
            
          case 'teleport':
            const empty = [];
            for(let r=0; r<gridSize; r++) {
              for(let c=0; c<gridSize; c++) {
                if(board[r][c] === null && !freezeCells.has(r*gridSize+c)) {
                  empty.push({r,c});
                }
              }
            }
            if(empty.length > 0) {
              const {r, c} = empty[Math.floor(Math.random()*empty.length)];
              board[tile.row][tile.col] = null;
              board[r][c] = tile;
              tile.row = r;
              tile.col = c;
            }
            break;
            
          case 'shuffle':
            const allTiles = [...tiles];
            const positions = [];
            
            for(let r=0; r<gridSize; r++) {
              for(let c=0; c<gridSize; c++) {
                if(board[r][c] === null && !freezeCells.has(r*gridSize+c)) {
                  positions.push({r,c});
                }
              }
            }
            
            shuffleArray(allTiles);
            shuffleArray(positions);
            
            for(let r=0; r<gridSize; r++) {
              for(let c=0; c<gridSize; c++) {
                board[r][c] = null;
              }
            }
            
            tiles = [];
            for(let i=0; i<allTiles.length; i++) {
              const tile = allTiles[i];
              if(i < positions.length) {
                tile.row = positions[i].r;
                tile.col = positions[i].c;
                board[tile.row][tile.col] = tile;
              }
              tiles.push(tile);
            }
            break;
            
          case 'mirror':
            mirrorMode = true;
            mirrorMovesLeft = 3;
            break;
            
          case 'double':
            doubleMode = true;
            doubleMovesLeft = 5;
            break;
        }
        
        // –£–¥–∞–ª—è–µ–º —Å–ø–µ—Ü—ç—Ñ—Ñ–µ–∫—Ç –ø–æ—Å–ª–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏
        tile.special = null;
      }
    }

    // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è –º–∞—Å—Å–∏–≤–∞
    function shuffleArray(array) {
      for(let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function startGame() {
      createGrid();
      initBoard();
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
    document.addEventListener('keydown', e => {
      if(menu.classList.contains('hidden')) {
        switch(e.key) {
          case 'ArrowUp': move('up'); break;
          case 'ArrowDown': move('down'); break;
          case 'ArrowLeft': move('left'); break;
          case 'ArrowRight': move('right'); break;
        }
      }
    });

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–≤–∞–π–ø–æ–≤ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;

    gameContainer.addEventListener('touchstart', e => {
      touchStartX = e.changedTouches[0].screenX;
      touchStartY = e.changedTouches[0].screenY;
    }, false);

    gameContainer.addEventListener('touchend', e => {
      touchEndX = e.changedTouches[0].screenX;
      touchEndY = e.changedTouches[0].screenY;
      handleSwipe();
    }, false);

    function handleSwipe() {
      if(menu.classList.contains('hidden')) {
        const dx = touchEndX - touchStartX;
        const dy = touchEndY - touchStartY;
        
        if(Math.abs(dx) > Math.abs(dy)) {
          if(dx > 50) move('right');
          else if(dx < -50) move('left');
        } else {
          if(dy > 50) move('down');
          else if(dy < -50) move('up');
        }
      }
    }
  })();
  </script>
</body>
</html>
