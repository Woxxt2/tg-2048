<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2048 Color Edition</title>
  <style>
    body {
      margin: 0; font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(to right, #1e1e2f, #2b2d42);
      color: white; display: flex; flex-direction: column; align-items: center; padding: 20px;
      height: 100vh; user-select: none;
    }
    h1 {
      margin-bottom: 10px;
      color: #ffcc00;
    }
    #game {
      position: relative;
      background: #12131a;
      border-radius: 15px;
      box-shadow: 0 0 15px rgba(0,0,0,0.4);
      display: grid;
      gap: 10px;
      margin-top: 20px;
      touch-action: none;
    }
    .cell {
      background: #222430;
      border-radius: 10px;
      box-shadow: inset 0 0 5px #000;
      border: 1px solid #44475a;
      position: relative;
    }
    .grid-line {
      position: absolute;
      background: rgba(255,255,255,0.1);
      pointer-events: none;
      z-index: 1;
    }
    /* –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ */
    #game .v-line {
      width: 1px; top: 0; bottom: 0;
    }
    /* –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ */
    #game .h-line {
      height: 1px; left: 0; right: 0;
    }
    .tile {
      position: absolute;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      text-shadow: 1px 1px 2px black;
      transition: top 0.2s ease, left 0.2s ease, transform 0.2s ease;
      user-select: none;
      cursor: default;
    }
    .tile[data-val="2"] { background-color: #FF6B6B; }
    .tile[data-val="4"] { background-color: #4ECDC4; }
    .tile[data-val="8"] { background-color: #45B7D1; }
    .tile[data-val="16"] { background-color: #FFBE0B; }
    .tile[data-val="32"] { background-color: #FB5607; }
    .tile[data-val="64"] { background-color: #8338EC; }
    .tile[data-val="128"] { background-color: #3A86FF; }
    .tile[data-val="256"] { background-color: #FF006E; }
    .tile[data-val="512"] { background-color: #9B5DE5; }
    .tile[data-val="1024"] { background-color: #00BBF9; }
    .tile[data-val="2048"] { background-color: #00F5D4; font-size: 24px; }
    .tile[data-val="4096"] { background-color: #F15BB5; font-size: 22px; }
    .tile[data-val="8192"] { background-color: #9B5DE5; font-size: 20px; }

    /* –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ */
    .tile.bomb {
      background-color: red;
      animation: pulse 1s infinite;
    }
    .tile.freeze {
      background-color: #0055ff;
    }
    .tile.teleport {
      background-color: #00ff99;
    }
    .tile.shuffle {
      background-color: #ff00ff;
    }
    .tile.mirror {
      background-color: #ff8800;
    }
    .tile.double {
      background-color: #8800ff;
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    #menu {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: white;
      user-select: none;
    }
    #menu.hidden {
      display: none;
    }
    .mode-buttons {
      display: flex;
      gap: 15px;
      margin: 15px 0;
    }
    button {
      background-color: #ffcc00;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      color: #2b2d42;
      user-select: none;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #e6b800;
    }
    button.active {
      background-color: #00f5d4;
      color: #2b2d42;
    }
    #specialToggle {
      margin-bottom: 10px;
    }
    #score {
      font-size: 20px;
      margin-top: 10px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="menu">
    <h1>2048 Color Edition</h1>
    <h2>–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º –∏–≥—Ä—ã</h2>
    <div class="mode-buttons">
      <button class="mode-btn active" data-size="4">4√ó4 (–∫–ª–∞—Å—Å–∏–∫–∞)</button>
      <button class="mode-btn" data-size="6">6√ó6</button>
      <button class="mode-btn" data-size="8">8√ó8 (—ç–∫—Å—Ç—Ä–∏–º)</button>
    </div>
    <button id="specialToggle">–û—Ç–∫–ª—é—á–∏—Ç—å —Å–ø–µ—Ü. –∫–ª–µ—Ç–∫–∏</button>
    <button id="startBtn">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
  </div>

  <div id="score">–°—á—ë—Ç: 0</div>
  <div id="game"></div>

  <script>
  (() => {
    const gameContainer = document.getElementById('game');
    const menu = document.getElementById('menu');
    const startBtn = document.getElementById('startBtn');
    const modeButtons = document.querySelectorAll('.mode-btn');
    const specialToggle = document.getElementById('specialToggle');
    const scoreElem = document.getElementById('score');

    let gridSize = 4;
    let specialEnabled = true;
    let board = [];
    let tiles = [];
    let tileSize = 0;
    let score = 0;
    let freezeCells = new Set(); // –∑–∞–º–æ—Ä–æ–∂–µ–Ω–Ω—ã–µ –∫–ª–µ—Ç–∫–∏, –∏–Ω–¥–µ–∫—Å—ã
    let mirrorMode = false;

    // –°–ø–µ—Ü. —Ç–∏–ø—ã —Å –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é (–≤ %)
    const specialTypes = [
      {type:'bomb', chance: 5},
      {type:'freeze', chance: 5},
      {type:'teleport', chance: 5},
      {type:'shuffle', chance: 3},
      {type:'mirror', chance: 3},
      {type:'double', chance: 3},
    ];

    // –í—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞
    modeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        modeButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        gridSize = +btn.dataset.size;
      });
    });

    // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Å–ø–µ—Ü. –∫–ª–µ—Ç–æ–∫
    specialToggle.addEventListener('click', () => {
      specialEnabled = !specialEnabled;
      specialToggle.textContent = specialEnabled ? '–û—Ç–∫–ª—é—á–∏—Ç—å —Å–ø–µ—Ü. –∫–ª–µ—Ç–∫–∏' : '–í–∫–ª—é—á–∏—Ç—å —Å–ø–µ—Ü. –∫–ª–µ—Ç–∫–∏';
    });

    startBtn.addEventListener('click', () => {
      startGame();
      menu.classList.add('hidden');
    });

    function createGrid() {
      gameContainer.innerHTML = '';
      freezeCells.clear();
      mirrorMode = false;

      gameContainer.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
      gameContainer.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
      gameContainer.style.width = `${gridSize * 80 + (gridSize - 1) * 10}px`;
      gameContainer.style.height = `${gridSize * 80 + (gridSize - 1) * 10}px`;
      tileSize = 80;

      // –†–∏—Å—É–µ–º —è—á–µ–π–∫–∏
      for(let i=0; i<gridSize*gridSize; i++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        cell.style.width = tileSize + 'px';
        cell.style.height = tileSize + 'px';
        gameContainer.appendChild(cell);
      }

      // –î–æ–±–∞–≤–ª—è–µ–º —Å–µ—Ç–∫—É –ª–∏–Ω–∏–π (–≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –∏ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ)
      // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
      for(let c=1; c<gridSize; c++) {
        const vline = document.createElement('div');
        vline.classList.add('grid-line', 'v-line');
        vline.style.left = (c * (tileSize + 10) - 5) + 'px';
        vline.style.top = '0px';
        vline.style.bottom = '0px';
        vline.style.height = '100%';
        gameContainer.appendChild(vline);
      }
      // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
      for(let r=1; r<gridSize; r++) {
        const hline = document.createElement('div');
        hline.classList.add('grid-line', 'h-line');
        hline.style.top = (r * (tileSize + 10) - 5) + 'px';
        hline.style.left = '0px';
        hline.style.right = '0px';
        hline.style.width = '100%';
        gameContainer.appendChild(hline);
      }
    }

    function newTileValue() {
      return Math.random() < 0.9 ? 2 : 4;
    }

    // –î–æ–±–∞–≤–∏—Ç—å —Å–ø–µ—Ü. –∫–ª–µ—Ç–∫—É —Å –Ω–µ–±–æ–ª—å—à–æ–π –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é
    function maybeSpecial() {
      if (!specialEnabled) return null;
      const rand = Math.random()*100;
      let sum = 0;
      for(const s of specialTypes) {
        sum += s.chance;
        if(rand <= sum) return s.type;
      }
      return null;
    }

    // –°–æ–∑–¥–∞–µ–º –ø–ª–∏—Ç–∫—É
    function createTile(value, row, col, special=null) {
      return {value, row, col, merged: false, special};
    }

    function initBoard() {
      board = [];
      for(let r=0; r<gridSize; r++) {
        const row = [];
        for(let c=0; c<gridSize; c++) {
          row.push(null);
        }
        board.push(row);
      }
      tiles = [];
      score = 0;
      scoreElem.textContent = `–°—á—ë—Ç: ${score}`;
      freezeCells.clear();
      mirrorMode = false;

      addRandomTile();
      addRandomTile();
      render();
    }

    // –î–æ–±–∞–≤–∏—Ç—å —Å–ª—É—á–∞–π–Ω—É—é –ø–ª–∏—Ç–∫—É
    function addRandomTile() {
      const empty = [];
      for(let r=0; r<gridSize; r++) {
        for(let c=0; c<gridSize; c++) {
          if(board[r][c] === null && !freezeCells.has(r*gridSize+c)) {
            empty.push({r,c});
          }
        }
      }
      if(empty.length === 0) return false;

      const {r, c} = empty[Math.floor(Math.random()*empty.length)];
      const val = newTileValue();
      const special = maybeSpecial();
      const tile = createTile(val, r, c, special);
      board[r][c] = tile;
      tiles.push(tile);
      return true;
    }

    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø–ª–∏—Ç–æ–∫
    function render() {
      // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –ø–ª–∏—Ç–∫–∏
      const oldTiles = [...gameContainer.querySelectorAll('.tile')];
      oldTiles.forEach(t => t.remove());

      // –î–æ–±–∞–≤–ª—è–µ–º –ø–ª–∏—Ç–∫–∏
      for(const tile of tiles) {
        const el = document.createElement('div');
        el.classList.add('tile');
        el.dataset.val = tile.value;
        el.style.width = tileSize + 'px';
        el.style.height = tileSize + 'px';
        el.style.top = (tile.row*(tileSize+10)) + 'px';
        el.style.left = (tile.col*(tileSize+10)) + 'px';

        if(tile.special) el.classList.add(tile.special);

        el.textContent = tile.special ? specialName(tile.special) : tile.value;
        if(tile.value >= 2048) el.style.fontSize = '24px';
        if(tile.value >= 4096) el.style.fontSize = '20px';

        gameContainer.appendChild(el);
      }
    }

    function specialName(type) {
      switch(type) {
        case 'bomb': return 'üí£';
        case 'freeze': return '‚ùÑÔ∏è';
        case 'teleport': return 'üåÄ';
        case 'shuffle': return 'üîÄ';
        case 'mirror': return 'üîÑ';
        case 'double': return '√ó2';
      }
      return '';
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–æ–∂–Ω–æ –ª–∏ —Ö–æ–¥–∏—Ç—å
    function canMove() {
      for(let r=0; r<gridSize; r++) {
        for(let c=0; c<gridSize; c++) {
          const tile = board[r][c];
          if(tile === null) return true; // –ø—É—Å—Ç–∞—è –∫–ª–µ—Ç–∫–∞ - –º–æ–∂–Ω–æ —Ö–æ–¥–∏—Ç—å
          // –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–æ—Å–µ–¥–µ–π –¥–ª—è —Å–ª–∏—è–Ω–∏—è
          const neighbors = [
            [r+1,c], [r-1,c], [r,c+1], [r,c-1]
          ];
          for(const [nr,nc] of neighbors) {
            if(nr<0||nr>=gridSize||nc<0||nc>=gridSize) continue;
            const ntile = board[nr][nc];
            if(ntile && ntile.value === tile.value) return true;
          }
        }
      }
      return false;
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ö–æ–¥–∞ –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ dir = 'up','down','left','right'
    function move(dir) {
      if(mirrorMode) {
        if(dir === 'left') dir = 'right';
        else if(dir === 'right') dir = 'left';
        else if(dir === 'up') dir = 'down';
        else if(dir === 'down') dir = 'up';
      }

      let moved = false;
      resetMerged();

      const vector = {
        'left':  {x: -1, y: 0},
        'right': {x: 1, y: 0},
        'up':    {x: 0, y: -1},
        'down':  {x: 0, y: 1},
      }[dir];

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ –æ–±—Ö–æ–¥–∞ –ø–æ —Å—Ç—Ä–æ–∫–∞–º/—Å—Ç–æ–ª–±—Ü–∞–º –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
      const startRow = vector.y === 1 ? gridSize-1 : 0;
      const endRow = vector.y === 1 ? -1 : gridSize;
      const stepRow = vector.y === 1 ? -1 : 1;

      const startCol = vector.x === 1 ? gridSize-1 : 0;
      const endCol = vector.x === 1 ? -1 : gridSize;
      const stepCol = vector.x === 1 ? -1 : 1;

      // –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –∫–ª–µ—Ç–∫–∏ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
      for(let r = startRow; r !== endRow; r += stepRow) {
        for(let c = startCol; c !== endCol; c += stepCol) {
          const tile = board[r][c];
          if(tile === null) continue;
          if(freezeCells.has(r*gridSize+c)) continue; // –∑–∞–º–æ—Ä–æ–∂–µ–Ω–∞ - –Ω–µ –¥–≤–∏–≥–∞–µ—Ç—Å—è

          let nr = r, nc = c;
          while(true) {
            const nextR = nr + vector.y;
            const nextC = nc + vector.x;
            if(nextR < 0 || nextR >= gridSize || nextC < 0 || nextC >= gridSize) break;
            if(freezeCells.has(nextR*gridSize+nextC)) break; // –Ω–µ–ª—å–∑—è –∑–∞—Ö–æ–¥–∏—Ç—å –≤ –∑–∞–º–æ—Ä–æ–∂–µ–Ω–Ω—É—é

            const nextTile = board[nextR][nextC];
            if(nextTile === null) {
              // –ø—Ä–æ—Å—Ç–æ —Å–¥–≤–∏–Ω—É—Ç—å
              board[nextR][nextC] = tile;
              board[nr][nc] = null;
              tile.row = nextR; tile.col = nextC;
              nr = nextR; nc = nextC;
              moved = true;
            } else if(!nextTile.merged && nextTile.value === tile.value && tile.special === null && nextTile.special === null) {
              // —Å–ª–∏—è–Ω–∏–µ –¥–≤—É—Ö –ø–ª–∏—Ç–æ–∫ (—Å–ø–µ—Ü. –ø–ª–∏—Ç–∫–∏ –Ω–µ–ª—å–∑—è —Å–ª–∏—Ç—å)
              nextTile.value *= 2;
              nextTile.merged = true;
              board[nr][nc] = null;
              // —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—É—é –ø–ª–∏—Ç–∫—É –∏–∑ tiles
              tiles = tiles.filter(t => t !== tile);
              score += nextTile.value;
              scoreElem.textContent = `–°—á—ë—Ç: ${score}`;
              moved = true;

              // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è 2048+ ‚Äî –º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä—è—Ç—å
              // –£–¥–∞–ª—è–µ–º —Å–ø–µ—Ü —ç—Ñ—Ñ–µ–∫—Ç—ã —Å —ç—Ç–æ–π –ø–ª–∏—Ç–∫–∏ (–µ—Å–ª–∏ –±—ã–ª–∏)
              nextTile.special = null;

              break;
            } else {
              break;
            }
          }
        }
      }

      if(moved) {
        // –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å —Å–ø–µ—Ü. –∫–ª–µ—Ç–∫–∏ (–±–æ–Ω—É—Å—ã)
        handleSpecialTiles();
        addRandomTile();
        render();

        // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–Ω–µ—Ü –∏–≥—Ä—ã
        if(!canMove()) {
          alert(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –°—á—ë—Ç: ${score}`);
          menu.classList.remove('hidden');
        }
      }
    }

    // –°–±—Ä–æ—Å —Ñ–ª–∞–≥–∞ merged –ø–µ—Ä–µ–¥ —Ö–æ–¥
